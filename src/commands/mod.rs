//! Dialog command definitions

use cim_domain::Command;
use serde_json::Value;
use uuid::Uuid;

use crate::value_objects::{ContextVariable, Participant, Topic, Turn};

/// Start a new dialog
#[derive(Debug, Clone)]
pub struct StartDialog {
    /// Dialog's unique ID (generated by caller)
    pub id: Uuid,
    /// Type of dialog
    pub dialog_type: crate::DialogType,
    /// Primary participant
    pub primary_participant: Participant,
    /// Initial metadata
    pub metadata: Option<std::collections::HashMap<String, Value>>,
}

impl Command for StartDialog {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // Creating new aggregate
    }
}

/// End a dialog
#[derive(Debug, Clone)]
pub struct EndDialog {
    /// Dialog ID
    pub id: Uuid,
    /// Reason for ending
    pub reason: Option<String>,
}

impl Command for EndDialog {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the id field to find the aggregate
    }
}

/// Add a turn to the dialog
#[derive(Debug, Clone)]
pub struct AddTurn {
    /// Dialog ID
    pub dialog_id: Uuid,
    /// The turn to add
    pub turn: Turn,
}

impl Command for AddTurn {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the dialog_id field to find the aggregate
    }
}

/// Switch context/topic
#[derive(Debug, Clone)]
pub struct SwitchContext {
    /// Dialog ID
    pub dialog_id: Uuid,
    /// New topic
    pub topic: Topic,
}

impl Command for SwitchContext {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the dialog_id field to find the aggregate
    }
}

/// Update context variables
#[derive(Debug, Clone)]
pub struct UpdateContext {
    /// Dialog ID
    pub dialog_id: Uuid,
    /// Variables to update
    pub variables: std::collections::HashMap<String, Value>,
}

impl Command for UpdateContext {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the dialog_id field to find the aggregate
    }
}

/// Pause a dialog
#[derive(Debug, Clone)]
pub struct PauseDialog {
    /// Dialog ID
    pub id: Uuid,
}

impl Command for PauseDialog {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the id field to find the aggregate
    }
}

/// Resume a paused dialog
#[derive(Debug, Clone)]
pub struct ResumeDialog {
    /// Dialog ID
    pub id: Uuid,
}

impl Command for ResumeDialog {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the id field to find the aggregate
    }
}

/// Set dialog metadata
#[derive(Debug, Clone)]
pub struct SetDialogMetadata {
    /// Dialog ID
    pub dialog_id: Uuid,
    /// Metadata key
    pub key: String,
    /// Metadata value
    pub value: Value,
}

impl Command for SetDialogMetadata {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the dialog_id field to find the aggregate
    }
}

/// Add a participant to the dialog
#[derive(Debug, Clone)]
pub struct AddParticipant {
    /// Dialog ID
    pub dialog_id: Uuid,
    /// Participant to add
    pub participant: Participant,
}

impl Command for AddParticipant {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the dialog_id field to find the aggregate
    }
}

/// Remove a participant from the dialog
#[derive(Debug, Clone)]
pub struct RemoveParticipant {
    /// Dialog ID
    pub dialog_id: Uuid,
    /// Participant ID to remove
    pub participant_id: Uuid,
    /// Reason for removal
    pub reason: Option<String>,
}

impl Command for RemoveParticipant {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the dialog_id field to find the aggregate
    }
}

/// Mark a topic as complete
#[derive(Debug, Clone)]
pub struct MarkTopicComplete {
    /// Dialog ID
    pub dialog_id: Uuid,
    /// Topic ID
    pub topic_id: Uuid,
    /// Resolution/outcome
    pub resolution: Option<String>,
}

impl Command for MarkTopicComplete {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the dialog_id field to find the aggregate
    }
}

/// Add a context variable
#[derive(Debug, Clone)]
pub struct AddContextVariable {
    /// Dialog ID
    pub dialog_id: Uuid,
    /// Variable to add
    pub variable: ContextVariable,
}

impl Command for AddContextVariable {
    type Aggregate = crate::Dialog;

    fn aggregate_id(&self) -> Option<cim_domain::EntityId<Self::Aggregate>> {
        None // We'll use the dialog_id field to find the aggregate
    }
}
